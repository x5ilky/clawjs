useinterface Runtime

struct number! {
    id: string
}

impl number! {
    fn js_object(num: Self) JsObject {
        js := $.create_js_object()
        // | { type: "CreateVar"; name: string }
        js:set("type", "CreateVar")
        js:set("name", num.id)
        return js
    }

    fn set<T + Runtime>(num: Self, amount: T) void {
        // | { type: "Set"; target: string; value: IlValue }
        js := $.create_js_object()
        js:set("type", "Set")
        js:set("target", num.id)
        js:set("value", amount:to_scratch_value())

        $.label_push_object($scope, js)
    }
    fn change<T + Runtime>(num: Self, amount: T) void {
        // | { type: "Change"; target: string; value: IlValue }
        js := $.create_js_object()
        js:set("type", "Change")
        js:set("target", num.id)
        js:set("value", amount:to_scratch_value())
        $.label_push_object($scope, js)
    }
}

impl Runtime for number! {
    fn to_scratch_value(num: Self) JsObject {
        obj := $.create_js_object()
        // | { key: "Variable", name: string }
        obj:set("key", "Variable")
        obj:set("name", num.id)

        return obj
    }
}

impl<T + Runtime> Assign<T> for number! {
    fn assign(num: Self, to: T) number! {
        num:set(to)
        return num
    }
}

export fn make_number!() number! {
    v := number!::{
        id: $.reserve()
    }
    $.label_push_object(stat_label, v:js_object())
    return v
}

struct string! {
    id: string
}

impl string! {
    fn js_object(str: Self) JsObject {
        js := $.create_js_object()
        // | { type: "CreateVar"; name: string }
        js:set("type", "CreateVar")
        js:set("name", str.id)
        return js
    }

    fn set<T + Runtime>(str: Self, amount: T) void {
        // | { type: "Set"; target: string; value: IlValue }
        js := $.create_js_object()
        js:set("type", "Set")
        js:set("target", str.id)
        js:set("value", amount:to_scratch_value())

        $.label_push_object($scope, js)
    }
}

impl Runtime for string! {
    fn to_scratch_value(str: Self) JsObject {
        obj := $.create_js_object()
        // | { key: "Variable", name: string }
        obj:set("key", "Variable")
        obj:set("name", str.id)

        return obj
    }
}

impl<T + Runtime> Assign<T> for string! {
    fn assign(str: Self, to: T) string! {
        str:set(to)
        return str
    }
}

export fn make_string!() string! {
    v := string!::{
        id: $.reserve()
    }
    $.label_push_object(stat_label, v:js_object())
    return v
}



struct List!<T + Runtime> {
    id: string
}
impl<T + Runtime> List!<T> {
    fn js_object(list: Self<T>) JsObject {
        js := $.create_js_object()
        // | { type: "CreateList"; name: string }
        js:set("type", "CreateList")
        js:set("name", list.id)
        return js
    }

    fn push_single<U + Runtime>(list: Self<T>, value: U) void {
        js := $.create_js_object()
        // | { key: "Push", value: IlValue }
        js:set("type", "ListOper")
        js:set("list", list.id)
        inner := $.create_js_object()
        inner:set("key", "Push")
        inner:set("value", value:to_scratch_value())

        js:set("oper", inner)
        $.label_push_object($scope, js)
    }
    fn push<U + Serialize>(list: Self<T>, value: U) void {
        values := value:to_serialized()
        for i := 0 ; i < values:len() ; i += 1 {
            list:push_single(values:get(i))
        }
    }
    
    fn clear() void {
        js := $.create_js_object()
        // | { key: "Clear" }
        js:set("type", "ListOper")
        js:set("list", list.id)
        inner := $.create_js_object()
        inner:set("key", "Clear")

        js:set("oper", inner)
        $.label_push_object($scope, js)
    }
    fn remove_at<U + Runtime>(index: U) void {
        js := $.create_js_object()
        // | { key: "RemoveIndex", index: IlValue }
        js:set("type", "ListOper")
        js:set("list", list.id)
        inner := $.create_js_object()
        inner:set("key", "RemoveIndex")
        inner:set("index", index:to_scratch_value())

        js:set("oper", inner)
        $.label_push_object($scope, js)
    }
    fn insert<U + Runtime, V + Runtime>(value: V, index: U) void {
        js := $.create_js_object()
        // | { key: "Insert", value: IlValue, index: IlValue }
        js:set("type", "ListOper")
        js:set("list", list.id)
        inner := $.create_js_object()
        inner:set("index", index:to_scratch_value())
        inner:set("key", "Insert")
        inner:set("value", value:to_scratch_value())

        js:set("oper", inner)
        $.label_push_object($scope, js)
    }
    fn replace<U + Runtime, V + Runtime>(value: V, index: U) void {
        js := $.create_js_object()
        // | { key: "Replace", value: IlValue, index: IlValue }
        js:set("type", "ListOper")
        js:set("list", list.id)
        inner := $.create_js_object()
        inner:set("index", index:to_scratch_value())
        inner:set("key", "Replace")
        inner:set("value", value:to_scratch_value())

        js:set("oper", inner)
        $.label_push_object($scope, js)
    }
}

export fn make_list!<T>() List!<T> {
    v := List!<T>::{
        id: $.reserve()
    }
    $.label_push_object(stat_label, v:js_object())
    return v
}
import "std/display"

impl Sprite {
    fn on_flag(spr: Self, l: label) void {
        // | { type: "Flag"; target: string; label: string }
        js := $.create_js_object()
        js:set("type", "Flag")
        js:set("target", spr.id)
        js:set("label", $.label_get_name(l))
        $.label_push_object(stat_label, js)
        $.set_label(l)
    }
}

struct BinaryOperation {
    left: JsObject,
    right: JsObject,
    oper: string
}
impl Runtime for BinaryOperation {
    fn to_scratch_value(bo: Self) JsObject {
        js := $.create_js_object()
        // | { key: "BinaryOperation", oper: BinaryOperation, left: IlValue, right: IlValue }
        js:set("key", "BinaryOperation")
        js:set("oper", bo.oper)
        js:set("left", bo.left)
        js:set("right", bo.right)
        return js
    } 
}

impl<T + Runtime, U + Runtime> Add<U, BinaryOperation> for T {
    fn add(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Add"
        }
        return v
    }
}
impl<T + Runtime, U + Runtime> Sub<U, BinaryOperation> for T {
    fn sub(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Sub"
        }
        return v
    }
}
impl<T + Runtime, U + Runtime> Mul<U, BinaryOperation> for T {
    fn mul(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Mul"
        }
        return v
    }
}

impl<T + Runtime, U + Runtime> Div<U, BinaryOperation> for T {
    fn div(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Div"
        }
        return v
    }
}

impl<T + Runtime, U + Runtime> Lt<U, BinaryOperation> for T {
    fn lt(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Lt"
        }
        return v
    }
}

impl<T + Runtime, U + Runtime> Gt<U, BinaryOperation> for T {
    fn gt(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Gt"
        }
        return v
    }
}

impl<T + Runtime, U + Runtime> Lte<U, BinaryOperation> for T {
    fn lte(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Lte"
        }
        return v
    }
}
impl<T + Runtime, U + Runtime> Gte<U, BinaryOperation> for T {
    fn gte(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Gte"
        }
        return v
    }
}

impl<T + Runtime, U + Runtime> Gt<U, BinaryOperation> for T {
    fn gt(left: T, right: U) BinaryOperation {
        v := BinaryOperation::{
            left: left:to_scratch_value(),
            right: right:to_scratch_value(),
            oper: "Gt"
        }
        return v
    }
}
export fn move_steps<T + Runtime>(steps: T) void {
    js := $.create_js_object()
    js:set("type", "MoveSteps")
    js:set("value", steps:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn point_direction<T + Runtime>(deg: T) void {
    js := $.create_js_object()
    js:set("type", "PointDirection")
    js:set("value", deg:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn setx<T + Runtime>(x: T) void {
    js := $.create_js_object()
    js:set("type", "SetX")
    js:set("value", x:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn sety<T + Runtime>(y: T) void {
    js := $.create_js_object()
    js:set("type", "SetY")
    js:set("value", y:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn changex<T + Runtime>(x: T) void {
    js := $.create_js_object()
    js:set("type", "ChangeX")
    js:set("value", x:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn changey<T + Runtime>(y: T) void {
    js := $.create_js_object()
    js:set("type", "ChangeY")
    js:set("value", y:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn goto<T + Runtime, U + Runtime>(x: T, y: U) void {
    js := $.create_js_object()
    // | { type: "GotoXY"; x: IlValue; y: IlValue }
    js:set("type", "GotoXY")
    js:set("x", x:to_scratch_value())
    js:set("y", y:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn turn_right<T + Runtime>(deg: T) void {
    js := $.create_js_object()
    // | { type: "TurnRight"; degrees: IlValue }
    js:set("type", "TurnRight")
    js:set("degrees", deg:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn turn_left<T + Runtime>(deg: T) void {
    js := $.create_js_object()
    // | { type: "TurnLeft"; degrees: IlValue }
    js:set("type", "TurnLeft")
    js:set("degrees", deg:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn forever(l: label) void {
    // | { type: "Forever"; label: string }
    js := $.create_js_object()
    js:set("type", "Forever")
    js:set("label", $.label_get_name(l))
    $.label_push_object($scope, js)
    $.set_label(l)
}

export fn switch_costume<T + Runtime>(value: T) void {
    js := $.create_js_object()
    js:set("type", "SwitchCostume")
    js:set("value", value:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn next_costume() void {
    js := $.create_js_object()
    js:set("type", "NextCostume")
    $.label_push_object($scope, js)
}
export fn switch_backdrop<T + Runtime>(value: T) void {
    js := $.create_js_object()
    js:set("type", "SwitchBackdrop")
    js:set("value", value:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn next_backdrop() void {
    js := $.create_js_object()
    js:set("type", "NextBackdrop")
    $.label_push_object($scope, js)
}
export fn set_size<T + Runtime>(value: T) void {
    js := $.create_js_object()
    js:set("type", "SetSize")
    js:set("value", value:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn change_size<T + Runtime>(value: T) void {
    js := $.create_js_object()
    js:set("type", "ChangeSize")
    js:set("value", value:to_scratch_value())
    $.label_push_object($scope, js)
}

export fn show() void {
    js := $.create_js_object()
    js:set("type", "Show")
    $.label_push_object($scope, js)
}
export fn hide() void {
    js := $.create_js_object()
    js:set("type", "Hide")
    $.label_push_object($scope, js)
}
export fn set_layer_front() void {
    js := $.create_js_object()
    js:set("type", "GotoLayer")
    js:set("value", true)
    $.label_push_object($scope, js)
}
export fn set_layer_back() void {
    js := $.create_js_object()
    js:set("type", "GotoLayer")
    js:set("value", false)
    $.label_push_object($scope, js)
}
// todo: sound


export fn wait<T + Runtime>(seconds: T) void {
    js := $.create_js_object()
    js:set("type", "Wait")
    js:set("value", seconds:to_scratch_value())
    $.label_push_object($scope, js)
}
export fn runtime_if<T + Runtime>(predicate: T, block: label) void {
    js := $.create_js_object()
    js:set("type", "If")
    js:set("predicate", predicate:to_scratch_value())
    js:set("label", $.label_get_name(block))
    $.set_label(block)
    $.label_push_object($scope, js)
}